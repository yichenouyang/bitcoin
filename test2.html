<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Scrollama Demo: Fixed CSS</title>
	<meta name="description" content="Scrollama Demo: Fixed CSS">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<style>
		/* default / demo page */
		
		
		body {
			margin: 0;
			padding: 0;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
		}
		body {
			min-height: 1280px;
			font-weight: 300;
			color: #2a2a2a;
			background: #f7f5f2;
		}
		span{
			color:#F27F1B;
		}
		p,
		h1,
		h2{
			
		}
		h3{
			font-size: 3.4rem;
			margin: 1.5rem auto;
			font-weight: 900;
			letter-spacing: 0.05em;
		}
		h4,
		a {
			margin: 0;
			font-weight: 300;
		}
		a,
		a:visited,
		a:hover {
			color: #f30;
			text-decoration: none;
			border-bottom: 1px solid currentColor;
		}
		#intro {
			max-width: 70rem;
			margin: 5px auto;
			text-align: center;
			height: 10px;
			font-family: 'Open Sans', sans-serif;
			margin-bottom: 300px;
			color: #666;
			
		}
		.intro__overline {
			font-size: 1.4rem;
		}
		.intro__hed {
			font-size: 3.4rem;
			margin: 1.5rem auto;
			font-weight: 900;
			letter-spacing: 0.05em;
		}
		
		#outro {
			height: 640px;
			text-align: center;
			height: 10px;
			font-family: 'Open Sans', sans-serif;
	
			color: #666;
		}
		
		/* scrollama */
		#scroll {
			position: relative;
			width: 100%;
			height:  4500px;
    		margin:0px;
			border-top: 2px dashed #000;
			border-bottom: 1px dashed #000;
		}
		.scroll__graphic {
			position: absolute;
			top: 0;
			left: 0;
			bottom: auto;
			-webkit-transform: translate3d(0, 0, 0);
			-moz-transform: translate3d(0, 0, 0);
			transform: translate3d(0, 0, 0);
		}
		.scroll__graphic.is-fixed {
			position: fixed;
		}
		.scroll__graphic.is-bottom {
			bottom: 0;
			top: auto;
		}
		.chart {
			position: absolute;
			right: 1rem;
			top: 50%;
			-moz-transform: translateY(-50%);
			-webkit-transform: translateY(-50%);
			transform: translateY(-50%);
			background-color: #ddd;
			border: 1px solid #000;
		}
		.chart p {
			text-align: center;
			padding: 1rem;
			position: absolute;
			top: 50%;
			left: 50%;
			-moz-transform: translate(-50%, -50%);
			-webkit-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
			font-size: 1.4rem;
			color: #666;
			font-family: 'Open Sans', sans-serif;
		}
		.scroll__text {
			position: relative;
			padding: 0 1rem;
			max-width: 30rem;
			width: 33%;
		}
		.step {
			width: 1px;
			margin: 2rem auto;
			border: 1px solid #333;
		}
		.step.is-active {
			opacity: 1;
		}
	
		.marker {
      		position: fixed;
      		top: 0;
      		left: 0;
      		width: 100%;
      		height: 400px;
      		border: 1px solid #ccc;
    	}
  		.line {
			position: absolute;
    		height: 1500px;
    		top: -120px;
  		}
	</style>

</head>

<body>
	<section id='intro'>
		
		<h1 class='intro__hed'>Rise and Fall of <span>Bitcoin</span></h1>
		<p class = 'intro__overline'>The price of bitcoin rose and fell in the last two years. From less than<strong> $1000 </strong>in early 2017 to almost <strong>$20,000</strong> in late 2017 before an epic plunge that lose <strong>82% of the value</strong>, it has all the hallmarks of a bubble -- speculative buying, fear of missing out, a sudden frenzy of interest from the general public.<br><br>Follow the timeline, let's dive into the price fluctuation from the beginning of 2017 to the end of November 2018 and specific events coincided with them.</p>
		<p class='intro__dek'>
			(Start scrolling to see the whole story.)
		</p>
	</section>
	
	<section id='scroll'>
	
		
	<!--  graphic container  -->
	<div class='scroll__graphic'>
		<div class='chart' >
			<p>0</p>
		</div>
	</div>
	<div class="line">
    	<svg width="500" height="5000"></svg>
  	</div>

	<!--  step/text container  -->
	<div class='scroll__text'>
		
		
		<div class='step' data-step='1'>
			<p>STEP 1</p>
		</div>
		<div class='step' data-step='2'>
			<p>STEP 2</p>
		</div>
		<div class='step' data-step='3'>
			<p>STEP 3</p>
		</div>
		<div class='step' data-step='4'>
			<p>STEP 4</p>
		</div>
		<div class='step' data-step='5'>
			<p>STEP 4</p>
		</div>
		<div class='step' data-step='6'>
			<p>STEP 4</p>
		</div>
	</div>
		
	</section>

	
	<section id='outro'>
	<h3>So, What's next?</h3>
	<p class = 'intro__overline'>Looking back at bitcoins price fluctuation in the last two years, stomach-churning tumbles of 40%, one thing for sure is that the once most popular cryptocurrency is an extremely volatile asset, and highly sensitive to external factors like government regulation or cybersecurity. We expect a long way to go before it can function as a reliable medium of exchange.</p>
	</section>
	
	<div class='debug'></div>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.min.js"></script>
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src='https://unpkg.com/intersection-observer'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/scrollama/1.4.1/scrollama.min.js'></script>
	
	<script>
		var charttext=["From January to April, the price rose steadily from $965 to $1316. On May 21, BTC surpassed $2000 for the first time, and from there, continued to quickly gain traction at price.","bbb","ccc","ddd","eee","fff"]
		
	
		var container = d3.select('#scroll');
		var graphic = container.select('.scroll__graphic');
		var chart = graphic.select('.chart');
		var text = container.select('.scroll__text');
		var step = text.selectAll('.step');
		// initialize the scrollama
		var scroller = scrollama();
		// generic window resize listener event
		function handleResize() {
			// 1. update height of step elements
			var stepHeight = Math.floor(window.innerHeight * 0.75);
			step.style('height', stepHeight + 'px');
			// 2. update width/height of graphic element
			var bodyWidth = d3.select('body').node().offsetWidth;
			graphic
				.style('width', bodyWidth + 'px')
				.style('height', window.innerHeight + 'px');
			var chartMargin = 32;
			var textWidth = text.node().offsetWidth;
			var chartWidth = graphic.node().offsetWidth - textWidth - chartMargin;
			chart
				.style('width', chartWidth + 'px')
				.style('height', Math.floor(window.innerHeight / 2) + 'px');
			// 3. tell scrollama to update new element dimensions
			scroller.resize();
		}
		// scrollama event handlers
		function handleStepEnter(response) {
			// response = { element, direction, index }
			// add color to current step only
			step.classed('is-active', function (d, i) {
				return i === response.index;
			})
			// update graphic based on step
			chart.select('p').text(charttext[response.index])
		}
		function handleContainerEnter(response) {
			// response = { direction }
			// sticky the graphic (old school)
			graphic.classed('is-fixed', true);
			graphic.classed('is-bottom', false);
		}
		function handleContainerExit(response) {
			// response = { direction }
			// un-sticky the graphic, and pin to top/bottom of container
			graphic.classed('is-fixed', false);
			graphic.classed('is-bottom', response.direction === 'down');
		}
		function init() {
			// 1. force a resize on load to ensure proper dimensions are sent to scrollama
			handleResize();
			// 2. setup the scroller passing options
			// this will also initialize trigger observations
			// 3. bind scrollama event handlers (this can be chained like below)
			scroller.setup({
				container: '#scroll',
				graphic: '.scroll__graphic',
				text: '.scroll__text',
				step: '.scroll__text .step',
				
			})
				.onStepEnter(handleStepEnter)
				.onContainerEnter(handleContainerEnter)
				.onContainerExit(handleContainerExit);
			// setup resize event
			window.addEventListener('resize', handleResize);
			
			
		//line start 		
		function prepareData(price) {
      
        	let xScale = d3.scaleSqrt()
            .range([0, 600])
            .domain([750,20000])
		
		
		let newdata ={categoryX: 300, points: []}			
			price.map((d)=>{
				newdata.points.push({
				x:100+xScale(d.price),
				y:150+20*d.id,
				t:d.time,
			})
			})
		return newdata 
    		}
	
	d3.csv("price.csv").then((price)=>{
		data = prepareData(price)
		console.log(data)

    var svg = d3.select('svg');
    var distancePath = svg.append('path')
      .attr('fill', 'none')
      .attr('stroke', 'none').node();

    var source;
    var target;
    var gap = 100;
    var totalDistance = 0;
    _.each(data.points, function(target) {
      if (!source) {
        target.d = 'M' + target.x + ',' + target.y;
      } else {
        if (source.y > target.y - gap) {
          // if they're sufficiently close to each other
          if (source.x === target.x) {
            target.d = drawLine(target.x, target.y);
            setDistance(source, target);
          } else {
            target.d = drawCurve(source.x, source.y, target.x, target.y);

            setDistance(source, target);
            target.y1 = target.y - source.y;
            target.interpolate1 = d3.interpolate(0, target.distance);
          }
        } else {
          target.d = '';
          if (source.x !== data.categoryX) {
            // if the source repo owner isn't the same as the contributor, move the line back
            target.d += drawCurve(source.x, source.y, data.categoryX, source.y + gap / 3);

            setDistance(source, target);
            target.y1 = gap / 3;
            target.interpolate1 = d3.interpolate(0, target.distance);
          }

          x = target.x;
          y = target.y;
          if (target.x !== data.categoryX) {
            x = data.categoryX;
            y = target.y - gap / 3;
          }
          
          target.d += drawLine(x, y);
          target.y2 = y - (target.y1 || 0);
          setDistance(source, target);

          if (target.x !== data.categoryX) {
            target.d += drawCurve(x, y, target.x, target.y);
            var currentDistance = target.distance;
            setDistance(source, target);
            target.y3 = gap / 3;
            target.interpolate2 = d3.interpolate(0, target.distance - currentDistance);
          }
        }
        target.totalDistance = (totalDistance += target.distance);
        
      }
      source = target;
    });

    var path = svg.append('path')
      .attr('d', _.pluck(data.points, 'd').join(' '))
      .attr('fill-opacity', 0)
      .attr('stroke', '#3FB8AF')
      .attr('stroke-width', 4)
      .attr('stroke-linecap', 'round')
      .attr('stroke-dasharray', totalDistance)
      .attr('stroke-dashoffset', totalDistance);
    var circle = svg.selectAll('circle')
      .data(data.points).enter().append('circle')
      .attr('fill', '#fff')
      .attr('stroke', '#3FB8AF')
      .attr('stroke-width', 2)
      .attr('cx', function(d) {return d.x})
      .attr('cy', function(d) {return d.y})
      .attr('r', 4);

    window.addEventListener('scroll', _.throttle(windowScroll, 200));

    function windowScroll() {
      var top = scrollY + 50;
      var source;
      var target = _.find(data.points, function(point) {
        if (point.y >= top) {
          return true;
        }
        source = point;
        return false;
      });
      if (source && target) {
        var distance = 0;
        var distanceFromSource = top - source.y;
        if (!target.interpolate1) {
          // if there's no interpolate1
          if (!target.interpolate2) {
            // and there's no interpolate2, must mean it's a straight line
            distance = distanceFromSource + source.totalDistance;
          } else {
            // if there's a interpolate2, must mean there's a straight line
            // and then a curve at the end, so figure out if we're in straight line or curve part
            if (distanceFromSource <= target.y2) {
              // it's in straight line part
              distance = distanceFromSource + source.totalDistance;
            } else {
              // if it's in last curve part, first interpolate the curve
              // and then add that back to the straight part and the previous total distance
              var partialDistance = (distanceFromSource - target.y2) / target.y3;
              distance = target.interpolate2(partialDistance) + target.y2 + source.totalDistance;
            }
          }
        } else {
          // if there's interpolate1, must mean there's a first curve
          if (distanceFromSource <= target.y1) {
            // so if it's within the first curve, interpolate that and add it to total distance
            var partialDistance = distanceFromSource / target.y1;
            distance = target.interpolate1(partialDistance) + source.totalDistance;
          } else if (distanceFromSource <= (target.y1 + target.y2)) {
            // if we're in line part, add curve to it
            distance = target.interpolate1(1) + (distanceFromSource - target.y1) + source.totalDistance;
          } else if (interpolate2) {
            var partialDistance = (distanceFromSource - target.y2 - target.y1) / target.y3;
            distance = target.interpolate1(1) + target.y2 + target.interpolate2(partialDistance);
          }
        }
        // var partialDistance = (top - source.y) / (target.y - source.y);
        // var distance = target.interpolater(partialDistance) + source.totalDistance;
        path.transition().duration(200)
          .attr('stroke-dashoffset', totalDistance - (distance || 0));
      }
      
    };

    function drawLine(x, y) {
      return 'L' + x + ',' + y;
    }

    function drawCurve(x1, y1, x2, y2) {
      var cy = (y1 + y2) / 2;
      return 'C' + x1 + ',' + cy + ' ' + x2 + ',' + cy + ' ' + x2 + ',' + y2;
    }

    function setDistance(source, target) {
      var distancePathD = 'M' + source.x + ',' + source.y + ' ' + target.d;
      distancePath.setAttribute('d', distancePathD);
      target.distance = parseFloat(distancePath.getTotalLength().toFixed(2));
    }
})
			//line end
		}
		// kick things off
		init();
		
		
	</script>
</body>

</html>
